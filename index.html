<!-- index.html -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Diopter Range Calculator</title>

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="Diopter">
<meta name="theme-color" content="#000000">

<link rel="manifest" href="./manifest.json">

<style>
  :root{
    --bg:#000; --fg:#fff;
    --line:rgba(255,255,255,.18);
    --field:rgba(255,255,255,.08);
    --muted:rgba(255,255,255,.72);
    --warn:#ffd24a;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--fg); font:16px/1.35 -apple-system,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:720px; margin:0 auto; padding:16px 14px 28px; padding-top:calc(16px + env(safe-area-inset-top))}
  h1{font-size:18px; margin:0 0 12px}
  .card{border:1px solid var(--line); border-radius:14px; padding:14px; background:rgba(255,255,255,.03)}
  .grid{display:grid; gap:10px}
  .row{display:grid; grid-template-columns:1fr; gap:6px}
  label{font-size:12px; color:var(--muted); letter-spacing:.2px}
  input,select{
    width:100%; border:1px solid var(--line); background:var(--field); color:var(--fg);
    border-radius:12px; padding:12px 12px; font-size:16px; outline:none;
  }
  input::placeholder{color:rgba(255,255,255,.35)}
  .cols2{display:grid; grid-template-columns:1fr 1fr; gap:10px}
  .out{margin-top:12px; display:grid; gap:10px}
  .pill{
    border:1px solid var(--line); border-radius:14px; padding:12px; background:rgba(255,255,255,.03);
    display:flex; justify-content:space-between; gap:10px; align-items:baseline
  }
  .pill .k{color:var(--muted); font-size:12px}
  .pill .v{font-size:18px; font-variant-numeric:tabular-nums}
  .note{color:var(--muted); font-size:12px; margin-top:10px}
  .warn{color:var(--warn)}
  .mono{font-variant-numeric:tabular-nums}
  .small{font-size:13px}
</style>
</head>

<body>
<div class="wrap">
  <h1>Diopter Range Calculator</h1>

  <div class="card grid">
    <div class="cols2">
      <div class="row">
        <label>Lens (label only)</label>
        <input id="lens" placeholder="Tamashii 50mm" autocomplete="off" />
      </div>
      <div class="row">
        <label>Format (label only)</label>
        <select id="format">
          <option value="A35">Alexa 35 / S35</option>
          <option value="FF">Full Frame</option>
          <option value="S16">S16</option>
          <option value="Other">Other</option>
        </select>
      </div>
    </div>

    <div class="cols2">
      <div class="row">
        <label>Lens minimum focus (S) (feet/inches)</label>
        <input id="S" placeholder="Example: 2'6&quot;   or   30in   or   2.5ft" inputmode="decimal" autocomplete="off" />
      </div>
      <div class="row">
        <label>New close limit with diopter (X) (feet/inches)</label>
        <input id="X" placeholder="Leave blank to solve" inputmode="decimal" autocomplete="off" />
      </div>
    </div>

    <div class="cols2">
      <div class="row">
        <label>Diopter (D)</label>
        <select id="D">
          <option value="">— (solve)</option>
          <option value="0.5">+0.5</option>
          <option value="1">+1</option>
          <option value="2">+2</option>
          <option value="3">+3</option>
        </select>
      </div>
      <div class="row">
        <label>Sensor → diopter plane (L) (feet/inches)</label>
        <input id="L" placeholder="Example: 1'8&quot;   (leave blank to solve)" inputmode="decimal" autocomplete="off" />
      </div>
    </div>

    <div class="out">
      <div class="pill">
        <div class="k">New far limit (was ∞)</div>
        <div class="v mono" id="farOut">—</div>
      </div>
      <div class="pill">
        <div class="k">Solved field</div>
        <div class="v mono small" id="solvedOut">—</div>
      </div>
      <div class="pill">
        <div class="k">Exact diopter (if solved)</div>
        <div class="v mono small" id="exactDOut">—</div>
      </div>
      <div class="pill">
        <div class="k">Nearest standard diopter</div>
        <div class="v mono small" id="nearestDOut">—</div>
      </div>
    </div>

    <div class="note">
      Assumes diopter plane is near the front element.<br>
      Uses: <span class="mono">D = 1/(X−L) + 1/(S−L)</span> and <span class="mono">Far = L + 1/D</span>.
      <span class="warn">Positive diopters remove infinity.</span>
    </div>
  </div>
</div>

<script>
(() => {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js').catch(()=>{}));
  }

  const $ = (id) => document.getElementById(id);

  // --- feet/inches parsing to meters ---
  // Accepts: 2'6", 2' 6", 2.5ft, 30in, 30", 0.8m, 1'8-1/2"
  function parseDistanceToMeters(raw){
    if (!raw) return null;
    let s = raw.trim().toLowerCase();
    if (!s) return null;

    // normalize
    s = s.replace(/\s+/g,'');
    s = s.replace(/feet/g,'ft').replace(/foot/g,'ft').replace(/inches/g,'in').replace(/inch/g,'in');

    // meters explicit
    const mMatch = s.match(/^([0-9]*\.?[0-9]+)m$/);
    if (mMatch) return Number(mMatch[1]);

    // inches only: 30in or 30"
    const inMatch = s.match(/^([0-9]*\.?[0-9]+)(in|")$/);
    if (inMatch) return Number(inMatch[1]) * 0.0254;

    // feet only: 2.5ft or 2.5'
    const ftOnly = s.match(/^([0-9]*\.?[0-9]+)(ft|')$/);
    if (ftOnly) return Number(ftOnly[1]) * 0.3048;

    // feet + inches with optional fraction: 2'6", 2'6-1/2", 2'6.5"
    const ftIn = s.match(/^([0-9]*\.?[0-9]+)'([0-9]*\.?[0-9]+)?(?:-([0-9]+)\/([0-9]+))?(?:"|in)?$/);
    if (ftIn){
      const ft = Number(ftIn[1]);
      const inchWhole = ftIn[2] ? Number(ftIn[2]) : 0;
      const fracNum = ftIn[3] ? Number(ftIn[3]) : 0;
      const fracDen = ftIn[4] ? Number(ftIn[4]) : 1;
      const inch = inchWhole + (fracNum && fracDen ? (fracNum/fracDen) : 0);
      return ft * 0.3048 + inch * 0.0254;
    }

    // bare number fallback (assume feet)
    const num = s.match(/^([0-9]*\.?[0-9]+)$/);
    if (num) return Number(num[1]) * 0.3048;

    return null;
  }

  // meters -> formatted feet/inches (nearest 1/8")
  function metersToFtIn(m){
    if (m == null || !isFinite(m) || m <= 0) return '—';
    const totalIn = m / 0.0254;
    let ft = Math.floor(totalIn / 12);
    let inch = totalIn - ft * 12;

    const eighths = Math.round(inch * 8);
    inch = eighths / 8;

    if (inch >= 12){
      ft += 1;
      inch -= 12;
    }

    const whole = Math.floor(inch);
    const frac = inch - whole;

    const fracStr = (() => {
      const n = Math.round(frac * 8);
      if (n === 0) return '';
      if (n === 1) return ' 1/8';
      if (n === 2) return ' 1/4';
      if (n === 3) return ' 3/8';
      if (n === 4) return ' 1/2';
      if (n === 5) return ' 5/8';
      if (n === 6) return ' 3/4';
      if (n === 7) return ' 7/8';
      return '';
    })();

    return `${ft}'${whole}${fracStr}"`;
  }

  function isPos(x){ return x != null && isFinite(x) && x > 0; }

  // Snap diopter to nearest standard
  const STANDARD = [0.5, 1, 2, 3];
  function nearestStandardD(D){
    let best = STANDARD[0], bestErr = Math.abs(D - best);
    for (const d of STANDARD){
      const e = Math.abs(D - d);
      if (e < bestErr - 1e-12) { best = d; bestErr = e; }
      // tie-break: pick stronger (higher) diopter
      if (Math.abs(e - bestErr) <= 1e-12 && d > best) best = d;
    }
    return best;
  }

  // --- Solvers ---
  // D = 1/(X-L) + 1/(S-L)
  function solveD(S, X, L){
    const a = S - L;
    const b = X - L;
    if (!(a > 0 && b > 0)) return null;
    return (1/a) + (1/b);
  }

  // X = L + 1 / ( D - 1/(S-L) )
  function solveX(S, D, L){
    const a = S - L;
    if (!(a > 0 && D > 0)) return null;
    const denom = D - (1/a);
    if (!(denom > 0)) return null;
    return L + (1/denom);
  }

  // S = L + 1 / ( D - 1/(X-L) )
  function solveS(X, D, L){
    const b = X - L;
    if (!(b > 0 && D > 0)) return null;
    const denom = D - (1/b);
    if (!(denom > 0)) return null;
    return L + (1/denom);
  }

  // Solve L from S, X, D:
  // Let Δ = X - S, solve quadratic for a = S - L:
  // D a^2 + (DΔ - 2)a - Δ = 0
  function solveL(S, X, D){
    if (!(D > 0)) return null;
    const delta = X - S;
    const A = D;
    const B = (D * delta) - 2;
    const C = -delta;

    const disc = B*B - 4*A*C;
    if (!(disc >= 0)) return null;

    const sqrt = Math.sqrt(disc);
    const a1 = (-B + sqrt) / (2*A);
    const a2 = (-B - sqrt) / (2*A);

    // need a = S - L > 0 and also X - L > 0 => (X - (S - a)) = delta + a > 0
    const candidates = [a1, a2].filter(a => a > 0 && (delta + a) > 0 && isFinite(a));
    if (!candidates.length) return null;

    // choose the one that yields a physically sensible L (not negative huge): prefer smaller L (larger a)?? no:
    // pick the candidate that gives L within [0, S) if possible.
    let best = candidates[0];
    for (const a of candidates){
      const L = S - a;
      const Lbest = S - best;
      const ok = (L >= 0 && L < S);
      const okBest = (Lbest >= 0 && Lbest < S);
      if (ok && !okBest) best = a;
      if (ok === okBest){
        // prefer L >= 0 (closer to real rigs)
        if (L >= 0 && Lbest < 0) best = a;
        // then prefer smaller L magnitude
        if (Math.abs(L) < Math.abs(Lbest)) best = a;
      }
    }
    return S - best;
  }

  function compute(){
    const S_in = parseDistanceToMeters($('S').value);
    const X_in = parseDistanceToMeters($('X').value);
    const L_in = parseDistanceToMeters($('L').value);
    const D_in = $('D').value === '' ? null : Number($('D').value);

    const haveS = isPos(S_in);
    const haveX = isPos(X_in);
    const haveL = isPos(L_in);
    const haveD = D_in != null && isFinite(D_in) && D_in > 0;

    // decide which single field is missing
    const missing = [];
    if (!haveS) missing.push('S');
    if (!haveX) missing.push('X');
    if (!haveL) missing.push('L');
    if (!haveD) missing.push('D');

    let S = haveS ? S_in : null;
    let X = haveX ? X_in : null;
    let L = haveL ? L_in : null;
    let D = haveD ? D_in : null;

    let solvedLabel = '—';
    let exactDText = '—';
    let nearestDText = '—';

    if (missing.length === 1){
      const m = missing[0];

      if (m === 'D'){
        D = solveD(S, X, L);
        if (D != null && isFinite(D) && D > 0){
          solvedLabel = `Solved D from S, X, L`;
          exactDText = `+${D.toFixed(3)}`;
          const nd = nearestStandardD(D);
          nearestDText = `+${nd}`;
          // auto-set dropdown to nearest for usability, but keep exact displayed
          $('D').value = String(nd);
          D = nd;
        }
      }

      if (m === 'X'){
        X = solveX(S, D, L);
        if (X != null){
          solvedLabel = `Solved X from S, D, L`;
          $('X').value = metersToFtIn(X);
        }
      }

      if (m === 'S'){
        S = solveS(X, D, L);
        if (S != null){
          solvedLabel = `Solved S from X, D, L`;
          $('S').value = metersToFtIn(S);
        }
      }

      if (m === 'L'){
        L = solveL(S, X, D);
        if (L != null){
          solvedLabel = `Solved L from S, X, D`;
          $('L').value = metersToFtIn(L);
        }
      }
    }

    // outputs (far limit needs D and L)
    if (D != null && L != null && D > 0 && L > 0){
      const far = L + (1 / D);
      $('farOut').textContent = metersToFtIn(far);
    } else {
      $('farOut').textContent = '—';
    }

    $('solvedOut').textContent = solvedLabel;
    $('exactDOut').textContent = exactDText;
    $('nearestDOut').textContent = nearestDText;
  }

  // compute on edits
  ['S','X','L','D','lens','format'].forEach(id => {
    $(id).addEventListener('input', compute);
    $(id).addEventListener('change', compute);
  });

  compute();
})();
</script>
</body>
</html>
